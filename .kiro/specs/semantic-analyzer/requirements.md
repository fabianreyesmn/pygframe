# Requirements Document

## Introduction

The semantic analyzer is the third phase of a compiler that processes the Abstract Syntax Tree (AST) generated by the syntactic analyzer. It assigns, propagates, and verifies type and value attributes, constructs a symbol table, and detects semantic errors such as undeclared variables, type incompatibilities, and invalid conversions.

## Glossary

- **AST (Abstract Syntax Tree)**: Tree representation of the syntactic structure of source code generated in Phase 2
- **Semantic_Analyzer**: The system component that performs semantic analysis on the AST
- **Symbol_Table**: Data structure that stores information about identifiers including name, data type, scope, and memory address/offset
- **Annotated_AST**: AST enhanced with semantic attributes including type and value information
- **Semantic_Attributes**: Type and value information attached to AST nodes during semantic analysis
- **Type_System**: Component responsible for type checking, inference, and conversion rules
- **Error_Reporter**: Component that detects and reports semantic errors
- **Test_File**: TestSemantica.txt file containing test cases for validation

## Requirements

### Requirement 1

**User Story:** As a compiler developer, I want the semantic analyzer to process AST nodes and add semantic annotations, so that type and value information is available for code generation.

#### Acceptance Criteria

1. WHEN the Semantic_Analyzer receives an AST from the syntactic phase, THE Semantic_Analyzer SHALL traverse all nodes and add semantic attributes
2. THE Semantic_Analyzer SHALL propagate inherited and synthesized attributes between parent and child nodes
3. THE Semantic_Analyzer SHALL generate an Annotated_AST with type and value information for each node
4. THE Semantic_Analyzer SHALL preserve the original AST structure while adding semantic information
5. THE Semantic_Analyzer SHALL support attribute propagation for variable declarations, assignments, and expressions

### Requirement 2

**User Story:** As a compiler developer, I want a symbol table to track all program identifiers, so that variable declarations and usage can be validated.

#### Acceptance Criteria

1. THE Semantic_Analyzer SHALL create a Symbol_Table containing all program identifiers
2. THE Symbol_Table SHALL store identifier name, data type, scope, and memory address for each entry
3. WHEN processing variable declarations, THE Semantic_Analyzer SHALL insert new entries into the Symbol_Table
4. THE Semantic_Analyzer SHALL support nested scopes and scope resolution for identifier lookup
5. THE Symbol_Table SHALL be exportable as a formatted table or text file

### Requirement 3

**User Story:** As a compiler developer, I want type verification and inference, so that type compatibility is enforced throughout the program.

#### Acceptance Criteria

1. THE Type_System SHALL implement type equivalence and promotion rules
2. WHEN processing expressions, THE Type_System SHALL verify operand and result type compatibility
3. THE Type_System SHALL perform automatic type conversions where valid
4. THE Type_System SHALL support primitive types (int, float, string, boolean) and their operations
5. THE Type_System SHALL validate function parameter and return types

### Requirement 4

**User Story:** As a compiler developer, I want semantic error detection and reporting, so that invalid programs are identified with clear error messages.

#### Acceptance Criteria

1. WHEN encountering undeclared variables, THE Error_Reporter SHALL generate "Variable not declared" errors
2. WHEN detecting duplicate identifiers in the same scope, THE Error_Reporter SHALL generate "Identifier already declared" errors
3. WHEN finding type incompatibilities, THE Error_Reporter SHALL generate "Type incompatible" errors
4. WHEN detecting invalid type conversions, THE Error_Reporter SHALL generate "Invalid type conversion" errors
5. THE Error_Reporter SHALL allow execution to continue after non-fatal errors

### Requirement 5

**User Story:** As a compiler user, I want to process test files through the semantic analyzer, so that I can validate the implementation with provided test cases.

#### Acceptance Criteria

1. THE Semantic_Analyzer SHALL read and process the Test_File (TestSemantica.txt)
2. THE Semantic_Analyzer SHALL generate tokens using the existing lexical analyzer
3. THE Semantic_Analyzer SHALL construct both base AST and Annotated_AST from the test input
4. THE Semantic_Analyzer SHALL display the complete Symbol_Table for the test program
5. THE Semantic_Analyzer SHALL generate a comprehensive semantic error report

### Requirement 6

**User Story:** As a compiler user, I want integration with the existing compiler phases, so that the semantic analyzer works seamlessly with lexical and syntactic analyzers.

#### Acceptance Criteria

1. THE Semantic_Analyzer SHALL integrate with the existing lexico.py module for token generation
2. THE Semantic_Analyzer SHALL integrate with the existing sintactico.py module for AST input
3. THE Semantic_Analyzer SHALL maintain compatibility with the existing GUI framework (pygframe.py)
4. THE Semantic_Analyzer SHALL provide output in formats compatible with existing error reporting
5. THE Semantic_Analyzer SHALL support the same file input mechanisms as previous phases